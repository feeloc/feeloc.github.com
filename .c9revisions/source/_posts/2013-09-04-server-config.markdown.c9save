{"ts":1384268196186,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"---\nlayout: post\ntitle: \"服务器配置，tengine，git，nodejs，grunt，mongodb……\"\ndate: 2013-09-04 21:58\ncomments: true\ncategories: nginx git node\n---\n>最近准备用nodejs+mongodb开发个网站，手上正好有个vps，装个centos，那就从头搭建个开发及生产环境吧，目前只需要考虑3点：\n>1、使用git作代码管理，push后能自动部署到前端资源中。\n>2、如果修改了node文件，需要push后能查看，在commit消息中加入`deploy`，代码全站部署。\n>3、前端资源在发布时压缩，为了更加灵活，在访问时合并，并不是发布时合并。\n<!-- more -->\n\n##一、tengine安装##\n>采用tengine完全是看中一些好用的模块，像`http_concat_module`之类的，不乏一些nginx商业版中的功能，taobao好样的。\n\n*   先安装centos的编译环境，一阵y，y，y后安装成功\n{% codeblock %}\nyum install gcc gcc-c++ gcc-g77 flex bison autoconf automake bzip2-devel zlib-devel ncurses-devel libjpeg-devel libpng-devel libtiff-devel freetype-devel pam-devel openssl-devel libxml2-devel gettext-devel pcre-devel make\n{% endcodeblock %}\n*  常用工具 全部安装，省得麻烦\n{% img http://feeloc.cn/downloads/images/2013-09-04/1.jpg 800 '安装成功' %}\n\n*   安装pcre，因为tengine依赖pcre\n    *   `yum install pcre`发现已经安装但版本比较老，反正编译tengine时候需要pcre源代码，更新最新版本\n{% img http://feeloc.cn/downloads/images/2013-09-04/2.png 800 %}\n    *   `yum remove pcre`发现有依赖无法删除\n{% img http://feeloc.cn/downloads/images/2013-09-04/3.png 800 %}\n    *   直接用`rpm -e --nodeps --allmatches pcre`，可安全卸载，`rpm -ql pcre | cat -n`查看下包情况，其实不用卸载\n{% img http://feeloc.cn/downloads/images/2013-09-04/4.png 800 %}\n    *   下载pcre源码包放入`/usr/localhost/src`中，好习惯\n{% codeblock pcre %}\ncd /usr/local/src\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.33.tar.gz\ntar  zxvf pcre-8.33.tar.gz\nmkdir /usr/local/pcre  #创建安装目录\ncd pcre-8.33\n./configure  --prefix=/usr/local/pcre  #配置\nmake\nmake install\n{% endcodeblock %}\n\n*   正式安装tengine服务器\n{% codeblock tengine %}\ncd /usr/local/src\nwget http://www.openssl.org/source/openssl-1.0.1e.tar.gz    #因为安装tengin需要openssl源码\ncd /usr/local/src\ntar  zxvf openssl-1.0.1e.tar.gz\nwget http://tengine.taobao.org/download/tengine-1.5.1.tar.gz\ntar  zxvf tengine-1.5.1\ncd tengine-1.5.1.tar.gz\n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_concat_module --with-openssl=/usr/local/src/openssl-1.0.1e --with-pcre=/usr/local/src/pcre-8.33  #配置\n#--with-pcre=/usr/local/src/pcre-8.13指向的是源码包解压的路径，而不是安装的路径，否则会报错\n#如果要使用css/js等合并请求加载，请务必安装module --with-http_concat_module，正是我们需要的\nmake    #挺长一段时间的编译过程\n>-e \"s|%%PID_PATH%%|/usr/local/nginx/logs/nginx.pid|\"\n>-e \"s|%%CONF_PATH%%|/usr/local/nginx/conf/nginx.conf|\"\n>-e \"s|%%ERROR_LOG_PATH%%|/usr/local/nginx/logs/error.log|\"\nmake install\n{% endcodeblock %}\n*   安装成功\n{% codeblock success %}\n/usr/local/nginx/sbin/nginx\nchown nobody.nobody -R /usr/local/nginx/html\nchmod 700 -R /usr/local/nginx/html\n{% endcodeblock %}\n*   访问http://ip发现成功界面\n{% img http://feeloc.cn/downloads/images/2013-09-04/5.jpg 800 %}\n\n*   为了方便管理服务，我们编写一个脚本来启动关闭重启重载配置文件等\n    *   行关闭服务\n{% codeblock kill%}\ncat /usr/local/nginx/logs/nginx.pid #得到进程ID\nkill id\n{% endcodeblock %}\n\n    *写shell脚本，`vi /etc/init.d/nginx`\n{% codeblock nginx.sh %}\n#!/bin/sh\n#\n# nginx - this script starts and stops the nginx daemin\n#\n# chkconfig:   - 85 15\n# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \\\n#               proxy and IMAP/POP3 proxy server\n# processname: nginx\n# config:      /usr/local/nginx/conf/nginx.conf\n# pidfile:     /usr/local/nginx/logs/nginx.pid\n\n# Source function library.\n. /etc/rc.d/init.d/functions\n\n# Source networking configuration.\n. /etc/sysconfig/network\n\n# Check that networking is up.\n[ \"$NETWORKING\" = \"no\" ] && exit 0\n\nnginx=\"/usr/local/nginx/sbin/nginx\"\nprog=$(basename $nginx)\n\nNGINX_CONF_FILE=\"/usr/local/nginx/conf/nginx.conf\"\n\nlockfile=/var/lock/subsys/nginx\n\nstart() {\n    [ -x $nginx ] || exit 5\n    [ -f $NGINX_CONF_FILE ] || exit 6\n    echo -n $\"Starting $prog: \"\n    daemon $nginx -c $NGINX_CONF_FILE\n    retval=$?\n    echo\n    [ $retval -eq 0 ] && touch $lockfile\n    return $retval\n}\n\nstop() {\n    echo -n $\"Stopping $prog: \"\n    killproc $prog -QUIT\n    retval=$?\n    echo\n    [ $retval -eq 0 ] && rm -f $lockfile\n    return $retval\n}\n\nrestart() {\n    configtest || return $?\n    stop\n    start\n}\n\nreload() {\n    configtest || return $?\n    echo -n $\"Reloading $prog: \"\n    killproc $nginx -HUP\n    RETVAL=$?\n    echo\n}\n\nforce_reload() {\n    restart\n}\n\nconfigtest() {\n  $nginx -t -c $NGINX_CONF_FILE\n}\n\nrh_status() {\n    status $prog\n}\n\nrh_status_q() {\n    rh_status >/dev/null 2>&1\n}\n\ncase \"$1\" in\n    start)\n        rh_status_q && exit 0\n        $1\n        ;;\n    stop)\n        rh_status_q || exit 0\n        $1\n        ;;\n    restart|configtest)\n        $1\n        ;;\n    reload)\n        rh_status_q || exit 7\n        $1\n        ;;\n    force-reload)\n        force_reload\n        ;;\n    status)\n        rh_status\n        ;;\n    condrestart|try-restart)\n        rh_status_q || exit 0\n            ;;\n    *)\n        echo $\"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\"\n        exit 2\nesac\n{% endcodeblock %}\n\n    *   加权限，开机启动\n{% codeblock check %}\nchmod +x /etc/init.d/nginx\ncd /et/init.d/\n/sbin/chkconfig nginx on\n/sbin/chkconfig --list nginx\nnginx          \t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off\n\n#使用以下命令操作nginx\nservice nginx start\nservice nginx stop\nservice nginx restart\nservice nginx reload\n\n/etc/init.d/nginx start\n/etc/init.d/nginx stop\n/etc/init.d/nginx restart\n/etc/init.d/nginx reload\n{% endcodeblock %}\n\n*   配置tengine，使之支持静态资源合并访问\n{% codeblock nginx配置文件 %}\ncd /usr/local/nginx/conf\nvi nginx.conf\n{% endcodeblock %}\n\n    *   1、打开gzip\n{% codeblock nginx配置文件 %}\ngzip on;\ngzip_min_length 1k;\ngzip_buffers 16 64k;\ngzip_http_version 1.1;\ngzip_comp_level 6;\ngzip_types text/plain application/x-javascript text/css application/xml;\ngzip_vary on\n{% endcodeblock %}\n\n    *   2、新建conf.d/asset.dogolang.com.conf，在nginx.conf 中 include conf.d/*.conf\n{% codeblock %}\n#静态文件\nserver {\n        listen       80;\n        server_name  ***********;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n        location /static/ {\n                root /***********;\n                concat on;\n                concat_max_files 20;\n        }\n}\n#顺便配置上呆会儿要用的nodejs的访问\nserver {\n        listen       80;\n        server_name  ***********;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n                proxy_pass    http://***********/;\n                proxy_redirect          off;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n{% endcodeblock %}\n    *   执行service nginx reload，更新下配置文件，成功！\n\n\n##二、安装GIT##\n*   安装git，gitosis\n{% codeblock git,gitosis安装 %}\nyum install git python python-setuptools\ncd /usr/local/src\ngit clone git://github.com/res0nat0r/gitosis.git\ncd gitosis\npython setup.py install\n{% endcodeblock %}\n\n*   在开发机器上生成rsa key，这儿我想用这台服务器做git管理员管理，所以就在这台机器上生成key\n{% codeblock %}\nssh-keygen -t rsa #不需要密码,一路回车就行(在本地操作)\ncp /root/.ssh/id_rsa.pub /tmp/id_rsa.pub  # 如果是其它机器就上传下，scp ~/.ssh/id_rsa.pub root@xxx:/tmp/\n{% endcodeblock %}\n\n*   直接用root账号生成git库，网上很多教程使用git账户，因为我对linux权限系统不太了解，最后想写git hooks时，各种命令找不到，各种权限问题，干脆直接用root\n{% codeblock %}\ngitosis-init < /tmp/id_rsa.pub\n#Initialized empty Git repository in /root/repositories/gitosis-admin.git/\n#Reinitialized existing Git repository in /root/repositories/gitosis-admin.git/\n{% endcodeblock %}\n\n*   将gitosis-admin库，clone下来，用来管理git库和用户权限，git本来也是采用git来做各种管理的\n{% codeblock %}\nmkdir /projects\ncd /projects\ngit clone ssh://root@127.0.0.1/gitosis-admin.git\ncd gitosis-admin\nvi gitosis-admin.conf\n[group gitosis-admin]\nwritable = gitosis-admin\nmembers = root@localhost\n\n#这儿的members要和keydir中的*.pub中的*号名一致\n#修改后，push\ngit add .\ngit commit -m \"add a user\"\ngit push\n{% endcodeblock %}\n*   在刚加的git用户的机器上init一个git库，并提交到git仓库中试下\n{% codeblock %}\ngit init\nremote add origin git@YOUR_SERVER_HOSTNAME:PROJECT.git\ngit add .\ngit commit -a -m \"init project\"\ngit push origin master:refs/heads/master\n\n#注：修改git项目的地址\ngit remote set-url origin ssh://git@domain.com:3022/~/Projects/p1.git\n#如果希望用代码库中的文件完全覆盖本地工作版本，方法如下：\ngit reset --hard\ngit pull\n#如果想针对文件回退本地修改，方法如下：\ngit checkout HEAD file/to/restore\n{% endcodeblock %}\n\n*   我在服务器上git clone一份，刚提交的代码，是一个小项目，呆会儿测试安装nodejs时候使用\n\n##三、安装nodejs##\n*   下载，编译，安装nodejs\n{% codeblock %}\ncd /usr/local/src/\nwget http://nodejs.org/dist/v0.10.17/node-v0.10.17.tar.gz\ntar zxvf node-v0.10.17.tar.gz\ncd node-v0.10.17\n./configure --prefix=/usr/local/node/0.10\nmake   #编译时间很久，或许是我机器不行，基本可以去做100个仰卧起坐\nmake install\n#将node放入环境变量中\necho \"export PATH=$PATH:/usr/local/node/0.10/bin\" >> ~/.bash_profile\n#更新环境变量\n. ~/.bash_profile\n#echo $PATH 发现node的bin目录已经在环境变量中\n#安装forever模块，启动管理node程序\nnpm install forever -g\n{% endcodeblock %}\n\n*   利用启动脚本，实现自动运行forever的node程序，实现开机自启动，`vi /etc/init.d/node`\n{% codeblock node.sh %}\n#!/bin/bash\n#\n# node      Start up node server daemon\n#\n# chkconfig: 345 85 15\n# description: Forever for Node.js\n#\nPATH=/usr/local/node/0.10/bin\nDEAMON=/projects/node/app.js\nLOG=/projects/logs/node/hosts_log\nPID=/tmp/forever.pid\n\ncase \"$1\" in\n    start)\n        forever start -l $LOG/forever.log -o $LOG/forever_out.log -e $LOG/forever_err.log --pidFile $PID --minUptime 5000 --spinSleepTime 2000 -a $DEAMON\n        ;;\n    stop)\n        forever stop --pidFile $PID $DEAMON\n        ;;\n    stopall)\n        forever stopall --pidFile $PID\n        ;;\n    restartall)\n        forever restartall --pidFile $PID\n        ;;\n    restart)\n        forever stop --pidFile $PID $DEAMON\n        forever start -l $LOG/forever.log -o $LOG/forever_out.log -e $LOG/forever_err.log --pidFile $PID --minUptime 5000 --spinSleepTime 2000 -a $DEAMON\n        ;;\n    list)\n        forever list\n        ;;\n    *)\n        echo \"Usage: /etc.init.d/node {start|stop|restart|reload|stopall|restartall|list}\"\n        exit 1\n        ;;\nesac\nexit 0\n{% endcodeblock %}\n\n*   开机自动运行\n{% codeblock %}\nchmod 755 /etc/init.d/node\ncd /etc/init.d/\nchkconfig node on\nchkconfig --list node\n{% endcodeblock %}\n\n##四、配置GIT钩子，实现自动部署##\n*   需要在客户端push后按照需求更新服务器代码，然后重启服务，所以我们要激活post-receive钩子。`vim **/**.git/hooks/post-receive`，如果commit -m \"[deploy]\"，含有[deploy]，就重启该服务\n{% codeblock post-receive.sh %}\n#!/bin/sh\n#\n# git autodeploy script when it matches the string \"[deploy]\"\n#\n# @author    icyleaf <icyleaf.cn@gmail.com>\n# @link      http://icyleaf.com\n# @version   0.1\n#\n# Usage:\n#       1. put this into the post-receive hook file itself below\n#       2. `chmod +x post-recive`\n#       3. Done!\n\n# Check the remote git repository whether it is bare\nIS_BARE=$(git rev-parse --is-bare-repository)\nif [ -z \"$IS_BARE\" ]; then\n        echo >&2 \"fatal: post-receive: IS_NOT_BARE\"\n        exit 1\nfi\n\n# Get the latest commit subject\nSUBJECT=$(git log -1 --pretty=format:\"%s\")\n\n# Deploy the HEAD sources to publish\nIS_PULL=$(echo \"$SUBJECT\" | grep \"\\[deploy\\]\")\nif [ -z \"$IS_PULL\" ]; then\n        echo >&2 \"tips: post-receive: IS_NOT_PULL\"\n        exit 1\nfi\n\n# Check the deploy dir whether it exists\nDEPLOY_DIR=********\nif [ ! -d $DEPLOY_DIR ] ; then\n        echo >&2 \"fatal: post-receive: DEPLOY_DIR_NOT_EXIST: \\\"$DEPLOY_DIR\\\"\"\n        exit 1\nfi\n\n# Check the deploy dir whether it is git repository\n#\n#IS_GIT=$(git rev-parse --git-dir 2>/dev/null)\n#if [ -z \"$IS_GIT\" ]; then\n#       echo >&2 \"fatal: post-receive: IS_NOT_GIT\"\n#       exit 1\n#fi\n\n# Goto the deploy dir and pull the latest sources\ncd $DEPLOY_DIR\n#env -i git reset --hard\nenv -i git pull\n\n# restart app.js\n*** restart     #部署脚本，重启该服务\n{% endcodeblock %}\n\n##五、mongoDB安装##\n*   源码安装及开机启动配置\n{% codeblock %}\n1、下载源码，注意64位和32位\ncd /usr/local/src/\nwget http://fastdl.mongodb.org/linux/mongodb-linux-i686-2.4.6.tgz\n2、解压，移动\ntar zxvf mongodb-linux-i686-2.4.6.tgz\nmv mongodb-linux-i686-2.4.6 /usr/local/mongodb\n3、创建数据目录，日志目录\ncd /usr/local/mongoDB\nmkdir -p ./data/db/\nmkdir logs\n4、以后台方式运行mongoDB\n/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/db --logpath=/usr/local/mongodb/logs/mongodb.log --fork\n5、开机启动mongoDB，将启动命令加入rc.local中\necho \"/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/db --logpath=/usr/local/mongodb/logs/mongodb.log --fork\" >> /etc/rc.local\n6、查看mongoDB运行日志\ntail -f /usr/local/mongodb/logs/mongodb.log\n7、查看mongoDB的运行状态\nps aux |grep mongodb\n\n\n注：参数解释:\n  --dbpath 数据库路径(数据文件)\n  --logpath 日志文件路径\n  --master 指定为主机器\n  --slave 指定为从机器\n  --source 指定主机器的IP地址\n  --pologSize 指定日志文件大小不超过64M.因为resync是非常操作量大且耗时，最好通过设置一个足够大的oplogSize来避免resync(默认的 oplog大小是空闲磁盘大小的5%)。\n  --logappend 日志文件末尾添加\n  --port 启用端口号\n  --fork 在后台运行\n  --only 指定只复制哪一个数据库\n  --slavedelay 指从复制检测的时间间隔\n  --auth 是否需要验证权限登录(用户名和密码)\n{% endcodeblock %}\n\n*   编写启动脚本\n{% codeblock monogo.sh %}\n#!/bin/bash\n#\n# auto start mongodb\n#\n# chkconfig: 345 85 15\n#\nmongopath=/usr/local/mongodb\ndbpath=/usr/local/mongodb/data/db\nlogpath=/usr/local/mongodb/logs/mongodb.log\npid=/tmp/mongodb.pid\nbind_ip=0.0.0.0\nport=27017\n\ncase \"$1\" in\n    start)\n        $mongopath/bin/mongod --dbpath=$dbpath --logpath=$logpath --bind_ip=$bind_ip --port=$port --auth --pidfilepath=$pid --fork\n        ;;\n    stop)\n        pid=`ps -o pid,command ax | grep mongod | awk '!/awk/ && !/grep/ {print $1}'`;\n        if [ \"${pid}\" != \"\" ]; then\n            kill -2 ${pid};\n            fi\n        ;;\n    *)\n        echo \"Usage: /etc/init.d/mongodb {start|stop}\"\n        exit 1\n        ;;\nesac\nexit 0\n{% endcodeblock %}\n\n*   开机自动运行\n{% codeblock %}\nchmod 755 /etc/init.d/mongo\ncd /etc/init.d/\nchkconfig mongo on\nchkconfig --list mongo\n{% endcodeblock %}\n\n*   利用脚本更方便管理mongoDB，这样就不用在rc.local中直接写启动脚本了，把`/etc/init.d/mongo start`，写进去就可以实现开机启动了\n\n##MySQL安装##\n\n*   安装cmake`mysql的编译工具`\n{%codeblock%}\n下载\nwget http://www.cmake.org/files/v2.8/cmake-2.8.12.tar.gz\n\ntar zxvf cmake-2.8.12.tar.gz\ncd cmake-2.8.12\n#反正是工具软件，就直接配置编译安装了#\n./configure\nmake #编译\nmake install #安装\n#漫长地过程后安装完成\n{%endcodeblock%}\n\n*   安装MySQL\n{%codeblock%}\n下载适合自己的版本`ftp://mirror.switch.ch/mirror/mysql/Downloads/`\nwget ftp://mirror.switch.ch/mirror/mysql/Downloads/MySQL-5.6/mysql-5.6.14.tar.gz\n\ngroupadd mysql #添加mysql组\nuseradd -g mysql mysql -s /bin/false #创建用户mysql并加入到mysql组，不允许mysql用户直接登录系统\nmkdir -p /data/mysql #创建MySQL数据库存放目录\nchown -R mysql:mysql /data/mysql #设置MySQL数据库目录权限\nmkdir -p /usr/local/mysql #创建MySQL安装目录\ncd /usr/local/src\ntar zxvf mysql-5.5.25a.tar.gz #解压\ncd mysql-5.5.25a\ncmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc #配置\nmake #编译\nmake install #安装\n\ncd /usr/local/mysql\ncp ./support-files/my-huge.cnf /etc/my.cnf #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可）\nvi /etc/my.cnf #编辑配置文件,在 [mysqld] 部分增加下面一行\ndatadir = /data/mysql #添加MySQL数据库路径\n:wq! #保存退出\n./scripts/mysql_install_db --user=mysql #生成mysql系统数据库\ncp ./support-files/mysql.server /etc/rc.d/init.d/mysqld #把Mysql加入系统启动\nchmod 755 /etc/init.d/mysqld #增加执行权限\nchkconfig mysqld on #加入开机启动\nvi /etc/rc.d/init.d/mysqld #编辑\nbasedir = /usr/local/mysql #MySQL程序安装路径\ndatadir = /data/mysql #MySQl数据库存放目录\nservice mysqld start #启动\nvi /etc/profile #把mysql服务加入系统环境变量：在最后添加下面这一行\nexport PATH=$PATH:/usr/local/mysql/bin\n:wq! #保存退出\n下面这两行把myslq的库文件链接到系统默认的位置，这样你在编译类似PHP等软件时可以不用指定mysql的库文件地址。\nln -s /usr/local/mysql/lib/mysql /usr/lib/mysql\nln -s /usr/local/mysql/include/mysql /usr/include/mysql\nshutdown -r now #需要重启系统，等待系统重新启动之后继续在终端命令行下面操作\nmysql_secure_installation #设置Mysql密码\n根据提示按Y 回车\n然后输入2次密码\n继续按Y 回车，直到设置完成\n或者直接修改密码/usr/local/mysql/bin/mysqladmin -u root -p password \"123456\" #修改密码\nservice mysqld restart #重启\n{%endcodeblock%}\n"]],"start1":0,"start2":0,"length1":0,"length2":15184}]],"length":15184}
